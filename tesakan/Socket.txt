socket_ի պահանջվող գրադարաններ
#include <sys/types.h> 
#include <sys/socket.h>

գրելաձև
int socket(int domain, int type, int protocol)

socket() սարքում է կապի վերջնակետ և վերադարձնում ֆայլի descriptor(թիվ որը հղված է դեպի վերջնակետ): Վերադարձվող ֆայլի descriptor@ կլինի ամենափոքր հնարավոր արժեքը:
domain արգւմենտը սահմանում է հաղորդակցության տիրույթ․Այն ընտրում է protocol―ի ընտանիք, որը կօգտագործվի հաղորդակցության համար։
Linux միջուկի կողմից ներկայումս հասկանալի ձևաչափերը ներառում են.

AF_UNIX      Local communication                        unix(7)
AF_LOCAL     Synonym for AF_UNIX
AF_INET      IPv4 Internet protocols                    ip(7)
AF_AX25      Amateur radio AX.25 protocol               ax25(4)
AF_IPX       IPX - Novell protocols
AF_APPLETALK AppleTalk                                  ddp(7)
AF_X25       ITU-T X.25 / ISO-8208 protocol             x25(7)
AF_INET6     IPv6 Internet protocols                    ipv6(7)
AF_DECnet    DECet protocol sockets
AF_KEY       Key  management protocol, originally de‐
                    veloped for usage with IPsec
AF_NETLINK   Kernel user interface device               netlink(7)
AF_PACKET    Low-level packet interface                 packet(7)
AF_RDS       Reliable Datagram Sockets (RDS) protocol   rds(7)
                                                               rds-rdma(7)
AF_PPPOX     Generic PPP transport layer, for setting
                    up L2 tunnels (L2TP and PPPoE)
AF_LLC       Logical  link  control  (IEEE 802.2 LLC)
                    protocol
AF_IB        InfiniBand native addressing
AF_MPLS      Multiprotocol Label Switching
AF_CAN       Controller Area Network  automotive  bus
                    protocol
AF_TIPC      TIPC, "cluster domain sockets" protocol
AF_BLUETOOTH Bluetooth low-level socket protocol
AF_ALG       Interface to kernel crypto API
AF_VSOCK     VSOCK   (originally  "VMWare  VSockets")   vsock(7)
                    protocol for hypervisor-guest communica‐
                    tion
AF_KCM       KCM  (kernel connection multiplexer) in‐
                    terface
AF_XDP       XDP (express data path) interface


---------------------------------socket―ի տեսակները----------------------------------------
------------SOCK_STREAM  
Ապահովում է հաջորդական, երկկողմանի բայթ հոսքեր հոսքային տվյալների փոխանցման մեխանիզմով: Այս վարդակային տեսակը տվյալներ է փոխանցում հուսալի հիմունքներով, կարգով և տիրույթից դուրս հնարավորություններով:UNIX տիրույթում SOCK_STREAM վարդակից տիպը աշխատում է խողովակի պես: Ինտերնետ տիրույթում SOCK_STREAM վարդակից տիպը ներդրված է փոխանցման կառավարման արձանագրության/Ինտերնետային արձանագրության (TCP/IP) արձանագրության վրա:Հոսքի վարդակն ապահովում է տվյալների երկկողմանի, հուսալի, հաջորդականացված և չկրկնվող հոսք՝ առանց գրառումների սահմանների:Այն կարող է տվյալները խմբից դուրս փոխանցել։
------------SOCK_DGRAM
Ապահովում է տվյալների գծապատկերներ, որոնք ֆիքսված առավելագույն երկարության առանց կապի հաղորդագրություններ են: Այս տեսակի վարդակից սովորաբար օգտագործվում են կարճ հաղորդագրությունների համար, ինչպիսիք են անունների սերվերը կամ ժամանակի սերվերը, քանի որ հաղորդագրությունների առաքման կարգն ու հուսալիությունը երաշխավորված չէ: UNIX տիրույթում SOCK_DGRAM վարդակից տեսակը նման է հաղորդագրությունների հերթին: Ինտերնետ տիրույթում SOCK_DGRAM վարդակից տիպը ներդրված է User Datagram Protocol/Internet Protocol (UDP/IP) արձանագրության վրա: Datagram վարդակն աջակցում է տվյալների երկկողմանի հոսքին, որը հաջորդականացված չէ, հուսալի կամ կրկնօրինակված չէ: Դատագրամի վարդակից հաղորդագրություններ ստացող գործընթացում կարող են հաղորդագրություններ գտնել կրկնօրինակված կամ ուղարկված կարգից տարբերվող հերթականությամբ: Այնուամենայնիվ, տվյալների մեջ ռեկորդային սահմանները պահպանվում են: Datagram վարդակները սերտորեն մոդելավորում են այն հարմարությունները, որոնք հայտնաբերված են բազմաթիվ ժամանակակից փաթեթային անջատիչ ցանցերում:
-----------SOCK_SEQPACKET 
Ապահովում է տեղեկատվության հաջորդական, հուսալի և չկրկնվող հոսք ֆիքսված մաքսիմում չափով:Սպառողից պահանջվում է կարդալ մի ամբողջ փաթեթ յուրաքանչյուր մուտքային system call-ով: 
-----------SOCK_RAW
Ապահովում է մուտք դեպի ներքին ցանցային protocols և interfaces: Այս տեսակի socket հասանելի է միայն root օգտվողի հեղինակություն ունեցող օգտատերերին կամ ոչ root օգտատերերին, ովքեր ունեն CAP_NUMA_ATTACH հնարավորություն: (Ոչ root հումքային socket մուտք գործելու համար chuser հրամանը վերագրում է CAP_NUMA_ATTACH հնարավորությունը CAP_PROPAGATE-ի հետ միասին: Լրացուցիչ տեղեկությունների համար տես chuser հրամանը:)

Raw sockets-ը հավելվածին թույլ է տալիս ուղիղ մուտք ունենալ ավելի ցածր մակարդակի հաղորդակցման protocols_ներին: Raw sockets-ը նախատեսված է առաջադեմ օգտատերերի համար, ովքեր ցանկանում են օգտվել protocol―ի որոշ առանձնահատկություններից, որոնք ուղղակիորեն հասանելի չեն սովորական interfaces միջոցով, կամ ովքեր ցանկանում են ստեղծել նոր  protocol գոյություն ունեցող ցածր մակարդակի protocols վրա:

----------SOCK_RDM        
Ապահովում է տվյալների գրամի հուսալի շերտ, որը չի երաշխավորում դասավորվածությունը
――――――――――SOCK_PACKET     
SOCK_PACKET-ը չի ապահովում զտում ըստ սարքի: (PF_PACKET վարդակները կարող են կապվել սարքի հետ՝ զանգահարելով bind:) Եթե ETH_P_IP նշված է վարդակից զանգի մեջ, ապա բոլոր սարքերից բոլոր IPv4 փաթեթները (օրինակ՝ Ethernets, PPP հղումներ, SLIP հղումներ և շրջադարձային սարքը) փոխանցվում են: դեպի վարդակից: Ընդհանուր վարդակից հասցեի կառուցվածքը վերադարձվում է recvfrom-ի կողմից, և sa_data անդամը պարունակում է սարքի անունը (օրինակ՝ eth0): Այնուհետև հավելվածը պետք է հրաժարվի ցանկացած սարքից, որը նրան չի հետաքրքրում: Խնդիրը կրկին այն է, որ չափազանց շատ տվյալներ կարող են վերադարձվել հավելված, ինչը կարող է խանգարել գերարագ ցանցին վերահսկելիս:Այն հնարավոր է որ հանված լինի։
Some socket types may not be implemented by all protocol families.
socket-ի տեսակը նշելուց բացի, այն կարող է ներառել ստորև նշված արժեքներից որևէ մեկի բիթային OR՝ փոփոխելու socket-ի վարքագիծը:
--------------------------------seleckt
select()-ն օգտագործում է ժամանակի դադար, որը struct timeval է (վայրկյաններով և միկրովայրկյաններով), մինչդեռ pselect() օգտագործում է struct timespec (վայրկյաններով և նանվայրկյաններով):
select()-ը կարող է թարմացնել ժամանակի արգումենտը՝ նշելու, թե որքան ժամանակ է մնացել: pselect()-ը չի փոխում այս արգումենտը:
select()-ը չունի sigmask արգումենտ և իրեն պահում է որպես pselect(), որը կոչվում է NULL sigmask:
Կոմպլեկտները շահարկելու համար տրամադրվում են չորս մակրո:
FD_ZERO()-ը մաքրում է հավաքածուն։
FD_SET() և FD_CLR() համապատասխանաբար ավելացնում և հեռացնում է տվյալ ֆայլի նկարագրիչը հավաքածուից:
FD_ISSET() փորձարկում է՝ տեսնելու, թե արդյոք ֆայլի նկարագրիչը հավաքածուի մաս է կազմում.
this is useful after select() returns.
nfds is the highest-numbered file descriptor in any of the three sets, plus 1.Timeout-ը վերին սահման է այն ժամանակի քանակի վրա, որն անցել է մինչև select() վերադարձը: Այն կարող է լինել զրո, ինչի արդյունքում select()-ը անմիջապես վերադառնա: (Սա օգտակար է հարցումների համար:) Եթե ժամանակի վերջնաժամկետը NULL է (ժամկետ չկա), select()-ը կարող է անորոշ ժամանակով արգելափակել:
sigmask-ը ազդանշանային դիմակի ցուցիչ է (տես sigprocmask(2)); եթե այն NULL չէ, ապա pselect()-ը նախ փոխարինում է ընթացիկ ազդանշանային դիմակը -sigmask-ով մատնանշվածով, այնուհետև կատարում է «ընտրել» գործառույթը և այնուհետև վերականգնում է սկզբնական ազդանշանի դիմակը:
Բացի ժամանակի արգումենտի ճշգրտության տարբերությունից, հետևյալ pselect()-ը կանչում է.
recv() ֆունկցիան պետք է վերադարձնի բուֆերային արգումենտով մատնանշված բուֆերին գրված հաղորդագրության երկարությունը: Հաղորդագրության վրա հիմնված վարդակների համար, ինչպիսիք են SOCK_DGRAM-ը և SOCK_SEQPACKET-ը, ամբողջ հաղորդագրությունը պետք է ընթերցվի մեկ գործողությամբ:
Htons ֆունկցիան ընդունում է 16-բիթանոց թիվ՝ host բայթերի հերթականությամբ և վերադարձնում է 16-բիթանոց թիվ՝ ցանցային բայթերի հերթականությամբ, որն օգտագործվում է TCP/IP ցանցերում (AF_INET կամ AF_INET6 հասցեների ընտանիք): Htons ֆունկցիան կարող է օգտագործվել IP պորտի համարը hosti բայթերի կարգով IP պորտի համարին ցանցային բայթերի հերթականությամբ փոխարկելու համար:
-------------------INADDR_ANY
Երբ պրոցեսը ցանկանում է ստանալ նոր մուտքային փաթեթներ կամ կապեր, այն պետք է կապի վարդակից տեղական ինտերֆեյսի հասցեին՝ օգտագործելով bind(2):

Այս դեպքում միայն մեկ IP վարդակից կարող է կապված լինել տվյալ տեղական (հասցե, նավահանգիստ) զույգին: Երբ կապի կանչում նշված է INADDR_ANY, վարդակը կկապվի բոլոր տեղական միջերեսներին:

Երբ listen(2)-ը կանչվում է չկապված վարդակից, վարդակն ինքնաբերաբար կապված է պատահական ազատ պորտին, որտեղ տեղական հասցեն սահմանված է INADDR_ANY:

Երբ connect(2)-ը կանչվում է չկապված վարդակից, վարդակն ինքնաբերաբար կապված է պատահական ազատ պորտին կամ օգտագործելի համօգտագործվող պորտին, որտեղ տեղական հասցեն սահմանված է INADDR_ANY...

Կան մի քանի հատուկ հասցեներ. INADDR_LOOPBACK (127.0.0.1) միշտ վերաբերում է տեղական հոսթին loopback սարքի միջոցով; INADDR_ANY (0.0.0.0) նշանակում է պարտադիր ցանկացած հասցե...
-------conect
Connect() ֆունկցիան պետք է փորձի միացում կատարել վարդակից: Ֆունկցիան ընդունում է հետևյալ արգումենտները.
syntax  
connect(int socket, const struct sockaddr *address,socklen_t address_len)
argument 
 1 socet Նշում է ֆայլի descriptor, որը կապված է socet_ին:
 2 address Ցույց է տալիս դեպի sockaddr structura―ի վրա, որը պարունակում է peer"ում հետ կապ ենք հաստատելու" հասցե: Հասցեի երկարությունը և ձևաչափը կախված են վարդակի հասցեների ընտանիքից:
 3 address_len Նշում է address արգումենտով մատնանշված sockaddr struct―ի երկարությունը:
 Եթե socket արդեն կապված չէ տեղական հասցեին, connect()-ը պետք է կապի այն հասցեի հետ, որը, եթե socket-ի հասցեների ընտանիքը AF_UNIX չէ, չօգտագործված տեղական հասցե է:
 Հաջողությամբ ավարտից հետո connect()-ը կվերադարձնի 0; Հակառակ դեպքում, -1-ը պետք է վերադարձվի և errno սահմանվի սխալը նշելու համար:
 -----------recv
       ssize_t recv(int sockfd, void *buf, size_t len, int flags);
       ssize_t recvfrom(int sockfd, void *restrict buf, size_t len, int flags, struct sockaddr *restrict src_addr,socklen_t *restrict addrlen);
       ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
recv(), recvfrom() և recvmsg() զանգերն օգտագործվում են վարդակից հաղորդագրություններ ստանալու համար: Դրանք կարող են օգտագործվել ինչպես անկապի, այնպես էլ միացման վրա հիմնված վարդակների վրա տվյալներ ստանալու համար: Այս էջը նախ նկարագրում է բոլոր երեք համակարգային զանգերի ընդհանուր հատկանիշները, այնուհետև նկարագրում է զանգերի միջև եղած տարբերությունները:Միակ տարբերությունը recv()-ի և read(2)-ի միջև դրոշակների առկայությունն է: Զրոյական դրոշների արգումենտով recv()-ն ընդհանուր առմամբ համարժեք է read(2)-ին  (բայց տե՛ս ՆՇՈՒՄՆԵՐ):
recv(sockfd, buf, len, flags); համարժեք է recvfrom(sockfd, buf, len, flags, NULL, NULL);
Բոլոր երեք զանգերը հաջողությամբ ավարտելու դեպքում վերադարձնում են հաղորդագրության երկարությունը: Եթե հաղորդագրությունը չափազանց երկար է՝ մատակարարված բուֆերում տեղավորվելու համար, ավելորդ բայթերը կարող են անտեսվել՝ կախված վարդակից, որտեղից ստացվել է հաղորդագրությունը:Եթե socket հաղորդագրություններ չկան, ստացվող զանգերը սպասում են հաղորդագրության գալուն, բացառությամբ այն դեպքերի, երբ վարդակից արգելափակված չէ (տես fcntl(2)), որի դեպքում -1 արժեքը վերադարձվում է, իսկ errno-ն սահմանվում է EAGAIN կամ EWOULDBLOCK:Ստացող զանգերը սովորաբար վերադարձնում են առկա ցանկացած տվյալներ, մինչև պահանջվող գումարը, այլ ոչ թե սպասում են պահանջվող ամբողջ գումարի ստացմանը: Հավելվածը կարող է օգտագործել select(2), poll(2) կամ epoll(7)՝ որոշելու, թե երբ են ավելի շատ տվյալներ հասնում վարդակից:The flags argument is formed by ORing one or more of the following values: MSG_CMSG_CLOEXEC (միայն recvmsg(), քանի որ Linux 2.6.23) Սահմանեք փակ-on-exec դրոշը UNIX տիրույթի ֆայլի descriptor_ի միջոցով ստացված ֆայլի նկարագրիչի համար՝ օգտագործելով SCM_RIGHTS գործողությունը (նկարագրված է unix(7)-ում): Այս դրոշը օգտակար է նույն պատճառներով, ինչ O_CLOEXEC դրոշը open(2):MSG_DONTWAIT (քանի որ Linux 2.2) Միացնում է չարգելափակող գործողությունը. եթե գործողությունը արգելափակվի, զանգը ձախողվում է EAGAIN կամ EWOULDBLOCK սխալով: Սա ապահովում է O_NONBLOCK դրոշը դնելու նման վարքագիծ (fcntl(2) F_SETFL գործողության միջոցով), սակայն տարբերվում է նրանով, որ MSG_DONTWAIT-ը մեկ զանգի տարբերակ է, մինչդեռ O_NONBLOCK-ը բաց ֆայլի նկարագրության կարգավորում է (տես open(2)): որը կազդի կանչի գործընթացի բոլոր շղթաների վրա, ինչպես նաև այլ գործընթացների վրա, որոնք պարունակում են ֆայլերի նկարագրիչներ, որոնք վերաբերում են նույն բաց ֆայլի նկարագրությանը:MSG_ERRQUEUE (սկսած Linux 2.2) Այս դրոշը նշում է, որ հերթագրված սխալները պետք է ստացվեն վարդակից սխալի հերթից: Սխալը փոխանցվում է օժանդակ հաղորդագրության մեջ, որի տեսակը կախված է արձանագրությունից (IPv4 IP_RECVERR-ի համար): Օգտագործողը պետք է մատակարարի բավարար չափի բուֆեր: Լրացուցիչ տեղեկությունների համար տե՛ս cmsg (3) և ip (7): Սխալի պատճառ դարձած սկզբնական փաթեթի օգտակար բեռը փոխանցվում է որպես սովորական տվյալ msg_iovec-ի միջոցով: Դատագրամի սկզբնական նպատակակետ հասցեն, որն առաջացրել է սխալ, տրամադրվում է msg_name-ի միջոցով:
atol	Convert string to long integer (function)
atof	Convert string to double (function)
strtol	Convert string to long integer (function)
INADDR_ANY-ի bind()-ը ՉԻ «ստեղծում պատահական IP»: Այն կապում է վարդակից բոլոր հասանելի միջերեսներին:

Սերվերի համար դուք սովորաբար ցանկանում եք կապել բոլոր ինտերֆեյսներին, ոչ միայն «localhost»-ին:

Եթե ցանկանում եք կապել ձեր վարդակից միայն localhost-ին, ապա շարահյուսությունը կլինի my_sockaddress.sin_addr.s_addr = inet_addr("127.0.0.1"); այնուհետև զանգահարեք bind(my_socket, (SOCKADDR *) &my_sockaddr, ...):

Ինչպես պատահում է, INADDR_ANY-ը հաստատուն է, որը հավասար է «զրոյի»:
htonl, htons, ntohl, ntohs - convert values between host and network byte order
փոփոխականը = է read() ֆունկցիայի միջոցով կարող ենք փոփոխականի մեջ պահել նշված սոկետից ստացված տվյալները read()-ը ստանում է արգումենտներ 

