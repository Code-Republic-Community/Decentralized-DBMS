Առաջին բանը, որ դուք պետք է անեք, երբ տեղադրեք Git-ը, ձեր օգտվողի անունը և էլփոստի հասցեն սահմանելն է: Սա կարևոր է, քանի որ յուրաքանչյուր Git commit օգտագործում է այս տեղեկատվությունը, և այն անփոփոխ կերպով ներառվում է այն պարտավորությունների մեջ, որոնք դուք սկսում եք ստեղծել.
 
$ git config --global user.name «John Doe»
$ git config --global user.email johndoe@example.com

Կրկին, դուք պետք է դա անեք միայն մեկ անգամ, եթե անցնեք --global տարբերակը, քանի որ Git-ը միշտ կօգտագործի այդ տեղեկատվությունը այն ամենի համար, ինչ դուք անում եք այդ համակարգում: Եթե ցանկանում եք դա չեղարկել այլ անունով կամ էլփոստի հասցեով որոշակի նախագծերի համար, կարող եք հրամանը գործարկել առանց --գլոբալ տարբերակի, երբ դուք այդ նախագծում եք: GUI գործիքներից շատերը կօգնեն ձեզ դա անել, երբ դրանք առաջին անգամ գործարկեք:

Այժմ, երբ ձեր ինքնությունը կարգավորված է, դուք կարող եք կարգավորել լռելյայն տեքստային խմբագրիչը, որը կօգտագործվի, երբ Git-ին անհրաժեշտ լինի մուտքագրել հաղորդագրություն: Եթե կազմաձևված չէ, Git-ն օգտագործում է ձեր համակարգի լռելյայն խմբագրիչը, որն ընդհանուր առմամբ Vim-ն է: Եթե ցանկանում եք օգտագործել այլ տեքստային խմբագրիչ, ինչպիսին է Emacs-ը, կարող եք անել հետևյալը.
 
$ git config --global core.editor emacs

Vim-ը և Emacs-ը հայտնի տեքստային խմբագրիչներ են, որոնք հաճախ օգտագործվում են Unix-ի վրա հիմնված համակարգերի մշակողների կողմից, ինչպիսիք են Linux-ը և Mac-ը: Եթե դուք ծանոթ չեք այս խմբագրիչներից որևէ մեկին կամ աշխատում եք Windows համակարգում, ապա ձեզ հարկավոր է հրահանգներ որոնել, թե ինչպես կարգավորել ձեր նախընտրած խմբագրիչը Git-ի միջոցով:

Եթե ցանկանում եք ստուգել ձեր կարգավորումները, կարող եք օգտագործել git config --list հրամանը՝ թվարկելու այն բոլոր կարգավորումները, որոնք Git-ը կարող է գտնել այդ պահին.
 
Հրաման ՝  git config --list

user.name=Ջոն Դո
user.email=johndoe@example.com
color.status=auto
color.branch=ավտո
color.interactive=auto
color.diff=ավտո
 
Դուք կարող եք ստեղներ տեսնել մեկից ավելի անգամ, քանի որ Git-ը կարդում է նույն բանալին տարբեր ֆայլերից (/etc/gitconfig և ~/ .gitconfig, օրինակ): Այս դեպքում Git-ն օգտագործում է վերջին արժեքը յուրաքանչյուր յուրահատուկ բանալի համար, որը տեսնում է: Կարող եք նաև ստուգել, թե ինչ է Git-ի կարծիքով որոշակի բանալու արժեքը՝ մուտքագրելով git config <key>:
Հրաման ՝ git config user.name
Ջոն Դո

Եթե երբևէ ձեզ օգնության կարիք ունենաք Git-ն օգտագործելիս, կան երեք եղանակ՝ ձեռքով էջը (manpage) օգնություն ստանալու համար Git հրամաններից որևէ մեկի համար.
 
$ git help <verb>
$ git <verb> --help
$ man git-<verb>
 
Օրինակ, դուք կարող եք ստանալ manpage օգնությունը config հրամանի համար՝ գործարկելով
 
$ git help config

Գլուխ 2
Եթե դուք կարող եք կարդալ միայն մեկ գլուխ Git-ի հետ աշխատելու համար, սա այն է: Այս գլուխն ընդգրկում է բոլոր հիմնական հրամանները, որոնք դուք պետք է անեք այն գործերի ճնշող մեծամասնությունը, որոնք, ի վերջո, ձեր ժամանակը կանցկացնեք Git-ի հետ: Գլխի վերջում դուք պետք է կարողանաք կազմաձևել և սկզբնավորել պահոցը, սկսել և դադարեցնել ֆայլերի հետևելը, ինչպես նաև փոփոխություններ կատարել և կատարել: Մենք նաև ձեզ ցույց կտանք, թե ինչպես կարգավորել Git-ը, որպեսզի անտեսի որոշ ֆայլեր և ֆայլերի օրինաչափություններ, ինչպես արագ և հեշտությամբ հետարկել սխալները, ինչպես թերթել ձեր նախագծի պատմությունը և դիտել փոփոխությունները կատարման միջև, և ինչպես մղել և հեռացնել հեռավոր պահեստներից: 

~~~~~~~~~~~~Initializing a Repository in an Existing Directory~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Եթե դուք սկսում եք հետևել գոյություն ունեցող նախագծին Git-ում, դուք պետք է գնաք նախագծի գրացուցակ և մուտքագրեք
 
$ git init
 
Սա ստեղծում է .git անունով նոր ենթացանց, որը պարունակում է ձեր բոլոր անհրաժեշտ պահոցի ֆայլերը՝ Git պահեստի կմախք: Այս պահին ձեր նախագծում դեռ ոչինչ չի հետևվում:Եթե ցանկանում եք սկսել գոյություն ունեցող ֆայլերի տարբերակների վերահսկումը (ի տարբերություն դատարկ գրացուցակի), հավանաբար պետք է սկսեք հետևել այդ ֆայլերին և կատարեք նախնական հանձնում: Դուք կարող եք դա անել մի քանի git ավելացնել հրամանների միջոցով, որոնք նշում են այն ֆայլերը, որոնք ցանկանում եք հետևել, որին հաջորդում է git commit:
 
$ git add *.c
$ git add LICENSE
$ git commit -m 'initial project version'
 
Մենք կանդրադառնանք, թե ինչ են անում այս հրամանները ընդամենը մեկ րոպեի ընթացքում: Այս պահին դուք ունեք Git պահոց՝ հետևված ֆայլերով և նախնական պարտավորությամբ:
~~~~~~~~~~~~~~~~~~~~~~~~~~~Cloning an Existing Repository~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Եթե ​​ցանկանում եք ստանալ գոյություն ունեցող Git պահեստի պատճենը, օրինակ՝ նախագիծը, որին ցանկանում եք նպաստել, ապա ձեզ անհրաժեշտ հրամանը git clone-ն է: Եթե ​​դուք ծանոթ եք այլ VCS համակարգերին, ինչպիսիք են Subversion-ը, կնկատեք, որ հրամանը «clone» է և ոչ «checkout»: Սա կարևոր տարբերակ է՝ պարզապես աշխատանքային պատճեն ստանալու փոխարեն, Git-ը ստանում է սերվերի ունեցած գրեթե բոլոր տվյալների ամբողջական պատճենը: Ծրագրի պատմության համար յուրաքանչյուր ֆայլի յուրաքանչյուր տարբերակը լռելյայնորեն ներքև է քաշվում, երբ գործարկում եք git clone-ը: Իրականում, եթե ձեր սերվերի սկավառակը փչանա, դուք հաճախ կարող եք օգտագործել ցանկացած հաճախորդի գրեթե ցանկացած կլոն՝ սերվերը վերադարձնելու այն վիճակին, որում եղել է, երբ այն կլոնավորվել է (կարող եք կորցնել սերվերի կողմի որոշ կեռիկներ և այլն, բայց բոլոր տարբերակված տվյալները կլինեն այնտեղ, ավելի մանրամասն տե՛ս Գլուխ 4):
Դուք կլոնավորում եք պահեստը git clone [url]-ով: Օրինակ, եթե ցանկանում եք կլոնավորել Git կապվող գրադարանը, որը կոչվում է libgit2, կարող եք դա անել այսպես.
 
$ git clone https://github.com/libgit2/libgit2
 
Այն ստեղծում է libgit2 անունով գրացուցակ, սկզբնավորում է .git գրացուցակը դրա ներսում, հանում է այդ պահոցի բոլոր տվյալները և ստուգում է վերջին տարբերակի աշխատանքային պատճենը: Եթե ​​մտնեք նոր libgit2 գրացուցակ, այնտեղ կտեսնեք նախագծի ֆայլերը, որոնք պատրաստ են աշխատելու կամ օգտագործելու համար: Եթե ​​ցանկանում եք կլոնավորել շտեմարանը libgit2-ից այլ անունով գրացուցակի մեջ, կարող եք դա նշել որպես հրամանի տողի հաջորդ տարբերակ.
 
$ git clone https://github.com/libgit2/libgit2 mylibgit

Այդ հրամանն անում է նույն բանը, ինչ նախորդը, բայց նպատակային գրացուցակը կոչվում է mylibgit: Git-ն ունի մի շարք տարբեր փոխանցման արձանագրություններ, որոնք կարող եք օգտագործել: Նախորդ օրինակը օգտագործում է https:// արձանագրությունը, բայց դուք կարող եք տեսնել նաև git:// կամ user@server:path/to/repo.git, որն օգտագործում է SSH փոխանցման արձանագրությունը։ Գլուխ 4-ը կներկայացնի բոլոր առկա տարբերակները, որոնք սերվերը կարող է ստեղծել ձեր Git պահոց մուտք գործելու համար, ինչպես նաև յուրաքանչյուրի առավելություններն ու թերությունները:
~~~~~~~~~~~~~~~~~~~~~~~~~~~Recording Changes to the Repository~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Դուք ունեք բարեխիղճ Git պահոց և այդ նախագծի համար նախատեսված checkout կամ working copy պատճեն: Դուք պետք է որոշ փոփոխություններ կատարեք և այդ փոփոխությունների նկարները կատարեք ձեր պահոցում ամեն անգամ, երբ նախագիծը հասնում է այն վիճակին, որը ցանկանում եք գրանցել: Հիշեք, որ ձեր աշխատանքային գրացուցակի յուրաքանչյուր ֆայլ կարող է լինել երկու վիճակներից մեկում՝ tracked (հետեվող) կամ untracked: Tracked ֆայլերը ֆայլեր են, որոնք եղել են վերջին լուսանկարում. դրանք կարող են լինել չփոփոխված, փոփոխված կամ բեմականացված (unmodified, modified, or staged): Untracked ֆայլերը մնացած ամեն ինչ են՝ ձեր աշխատանքային գրացուցակի ցանկացած ֆայլ, որը ձեր վերջին լուսանկարում չի եղել և ձեր բեմադրման տարածքում չի գտնվում: Երբ դուք առաջին անգամ կլոնավորեք պահեստը, ձեր բոլոր ֆայլերը racked and unmodified, քանի որ դուք պարզապես ստուգել եք դրանք և ոչինչ չեք խմբագրել: Երբ դուք խմբագրում եք ֆայլերը, Git-ը դրանք տեսնում է որպես փոփոխված, քանի որ դուք դրանք փոխել եք ձեր վերջին հանձնումից հետո: Դուք բեմադրում եք այս փոփոխված ֆայլերը, այնուհետև կատարում ձեր բոլոր փուլային փոփոխությունները, և ցիկլը կրկնվում է
~~~~~~~~~~~~~~~~~~~~~~~~~~~Checking the Status of Your Files~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Հիմնական գործիքը, որն օգտագործում եք՝ որոշելու համար, թե որ ֆայլերը որ վիճակում են, git status հրամանն է: Եթե ​​դուք գործարկում եք այս հրամանը անմիջապես կլոնից հետո, դուք պետք է տեսնեք նման բան.
 
$ git status
On branch master
nothing to commit, working directory clean

Սա նշանակում է, որ դուք ունեք մաքուր աշխատանքային գրացուցակ, այլ կերպ ասած՝ հետևված և փոփոխված ֆայլեր չկան(tracked and modified files): Git-ը նաև չի տեսնում չհետևված(untracked) ֆայլեր, այլապես դրանք կցուցարկվեն այստեղ:Վերջապես, հրամանն ասում է ձեզ, թե որ մասնաճյուղում եք դուք և տեղեկացնում, որ այն չի շեղվել սերվերի նույն ճյուղից: Առայժմ այդ ճյուղը միշտ «վարպետ» է, որը լռելյայն է. այստեղ դուք չեք անհանգստանա դրա մասին: Մասնաճյուղերը և հղումները մանրամասն քննարկվում են Գլուխ 3-ում: Ենթադրենք, դուք նոր ֆայլ եք ավելացնում ձեր նախագծին՝ պարզ README ֆայլ: Եթե ​​ֆայլը նախկինում գոյություն չուներ, և դուք գործարկում եք git կարգավիճակը, դուք տեսնում եք ձեր չհետևված ֆայլը այսպես.
 
$ echo 'My Project' > README
$ git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)
 
    README

ոչինչ չի ավելացվել, բայց չհետևված ֆայլեր կան (հետևելու համար օգտագործեք «git add») Դուք կարող եք տեսնել, որ ձեր նոր README ֆայլը չհետևված է, քանի որ այն գտնվում է «Չհետագծված ֆայլեր» վերնագրի տակ ձեր կարգավիճակի ելքում: Չհետևելը հիմնականում նշանակում է, որ Git-ը տեսնում է մի ֆայլ, որը դուք չունեիք նախորդ լուսանկարում (commit); Git-ը չի սկսի ներառել այն ձեր commit snapshot-ներում, քանի դեռ դուք հստակորեն չեք ասի դա անել: Դա անում է այնպես, որ դուք պատահաբար չսկսեք ներառել ստեղծված երկուական ֆայլերը կամ այլ ֆայլեր, որոնք դուք չէիք ուզում ներառել: Դուք ցանկանում եք սկսել ներառել README-ը, ուստի եկեք սկսենք հետևել ֆայլին:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Tracking New Files~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Որպեսզի սկսեք հետևել նոր ֆայլին, դուք օգտագործում եք git add հրամանը: README ֆայլին հետևելու համար կարող եք գործարկել սա.
 
$ git add README
 
Եթե նորից գործարկեք ձեր կարգավիճակի հրամանը, կարող եք տեսնել, որ ձեր README ֆայլն այժմ հետևված է և բեմադրված է, որպեսզի կատարվի.
 
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
 
    new file:   README
 
Դուք կարող եք ասել, որ այն բեմադրված է, քանի որ այն գտնվում է «Փոփոխություններ» վերնագրի ներքո: Եթե դուք commit եք անում այս պահին, ապա ֆայլի տարբերակը այն պահին, երբ գործարկեցիք git add-ը, այն է, ինչ կլինի պատմական պատկերում: Դուք կարող եք հիշել, որ երբ դուք ավելի վաղ գործարկեցիք git init-ը, այնուհետև գործարկեցիք git add (ֆայլեր), որը պետք է սկսեր հետևել ձեր գրացուցակում գտնվող ֆայլերին: Git add հրամանը վերցնում է ուղու անուն կամ ֆայլի կամ գրացուցակի համար; եթե դա գրացուցակ է, հրամանը ռեկուրսիվ կերպով ավելացնում է այդ գրացուցակի բոլոր ֆայլերը:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Staging Modified Files~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Եկեք փոխենք ֆայլը, որն արդեն հետևվել է: Եթե փոխեք նախկինում հետևված ֆայլը, որը կոչվում է «benchmarks.rb» և այնուհետև նորից գործարկեք ձեր git status հրամանը, դուք կստանաք հետևյալ տեսքը.

$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
 
    new file:   README
 
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
 
    modified: benchmarks.rb

Benchmarks.rb ֆայլը հայտնվում է Changed անունով բաժնի տակ, բայց չի բեմադրվում commit-ի համար, ինչը նշանակում է, որ ֆայլը, որը հետևվում է, փոփոխվել է աշխատանքային գրացուցակում, բայց դեռ չի բեմադրվել: Այն բեմադրելու համար գործարկում եք git add հրամանը: git add-ը բազմաֆունկցիոնալ հրաման է, որը դուք օգտագործում եք այն սկսելու հետևել նոր ֆայլերին, ֆայլերը բեմադրելու և այլ բաներ անելու համար, օրինակ՝ միաձուլման հակամարտող ֆայլերը որպես լուծված նշելու համար: Կարող է օգտակար լինել ավելի շատ մտածել այն որպես «ավելացնել այս բովանդակությունը հաջորդ commit-ին», այլ ոչ թե «ավելացնել այս ֆայլը նախագծին»: Եկեք հիմա գործարկենք git add-ը, որպեսզի բեմադրենք benchmarks.rb ֆայլը, այնուհետև նորից գործարկենք git կարգավիճակը

$ git add benchmarks.rb
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
 
    new file:   README
    modified:   benchmarks.rb
 Երկու ֆայլերն էլ բեմադրված են և կմտնեն ձեր հաջորդ հանձնառության մեջ: Այս պահին, ենթադրենք, դուք հիշում եք մի փոքր փոփոխություն, որը ցանկանում եք կատարել benchmarks.rb-ում, նախքան այն կատարելը: Դուք նորից բացում եք այն և կատարում այդ փոփոխությունը, և դուք պատրաստ եք commit անել: Այնուամենայնիվ, եկեք ևս մեկ անգամ գործարկենք git կարգավիճակը.
 
$ vim benchmarks.rb
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
 
    new file:   README
    modified:   benchmarks.rb
 
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
 
    modified:   benchmarks.rb
Ինչ է դժոխք. Այժմ benchmarks.rb-ը նշված է որպես staged և unstaged: Ինչպես է դա հնարավոր? Պարզվում է, որ Git-ը բեմադրում է ֆայլը ճիշտ այնպես, ինչպես այն է, երբ գործարկում եք git add հրամանը: Եթե դուք կատարում եք հիմա, ապա benchmarks.rb-ի տարբերակը, ինչպիսին այն էր, երբ վերջին անգամ գործարկեցիք git add հրամանը, այն է, թե ինչպես է այն մտնելու commit, այլ ոչ թե ֆայլի տարբերակը, ինչպես այն երևում է ձեր աշխատանքային գրացուցակում, երբ գործարկում եք git commit: Եթե դուք փոփոխում եք ֆայլը git add-ն գործարկելուց հետո, դուք պետք է նորից գործարկեք git add-ը, որպեսզի բեմադրեք ֆայլի վերջին տարբերակը.

$ git add benchmarks.rb
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
 
    new file:   README
    modified:   benchmarks.rb
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Short Status~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Չնայած git կարգավիճակի ելքը բավականին համապարփակ է, այն նաև բավականին խոսուն է: Git-ն ունի նաև կարճ կարգավիճակի դրոշակ, որպեսզի կարողանաք տեսնել ձեր փոփոխությունները ավելի կոմպակտ ձևով: Եթե դուք գործարկում եք git status -s կամ git status --short, դուք ստանում եք շատ ավելի պարզեցված արդյունք հրամանից:

$ git status -s
 
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt

կա 2 սյունակ օրինակ արաջին տողում առաջին սյունակը դատարկ է երկրորդը M 

?? ֊  այն ֆայլերը որոնք tracked չեն
 M - այն ֆայլերը որոնք փոփոխված են, և չեն բեմադրվում (unstaged)
M  - այն ֆայլերը որոնք փոփոխված են և բեմադրվում են (staged)
A  - այն ֆայլերը որոնք 
MM - այն ֆայլերը որոնք փոփոխվելուց հետո բեմադրվել են ապա նորից փոփոխվել

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Ignoring Files~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Հաճախ դուք կունենաք մի դասի ֆայլեր, որոնք չեք ցանկանում, որ Git-ն ավտոմատ կերպով ավելացնի կամ ցույց տա,որ untracked  չեն: Սրանք, ընդհանուր առմամբ, ավտոմատ կերպով ստեղծվող ֆայլեր են, ինչպիսիք են տեղեկամատյանների ֆայլերը կամ ֆայլերը, որոնք արտադրվում են ձեր կառուցման համակարգի կողմից: Նման դեպքերում դուք կարող եք ստեղծել ֆայլերի ցանկի օրինաչափություններ՝ դրանց համապատասխանելու համար .gitignore անունով: Ահա .gitignore ֆայլի օրինակ
$ cat .gitignore
*.[oa]
*~
 
Առաջին տողը Git-ին հուշում է անտեսել «.o» կամ «.a» վերջացող ցանկացած ֆայլ՝ օբյեկտ և արխիվային ֆայլեր, որոնք կարող են լինել ձեր կոդը ստեղծելու արդյունքը: Երկրորդ տողը Git-ին հուշում է անտեսել բոլոր ֆայլերը, որոնք ավարտվում են ~ ֊ով , որն օգտագործվում է բազմաթիվ տեքստային խմբագրիչների կողմից, ինչպիսիք են Emacs-ը՝ ժամանակավոր ֆայլերը նշելու համար: Կարող եք նաև ներառել տեղեկամատյան, tmp կամ pid գրացուցակ; ավտոմատ ձևավորված փաստաթղթեր; եւ այլն։ Նախքան սկսելը .gitignore ֆայլի կարգավորումն ընդհանուր առմամբ լավ գաղափար է, որպեսզի պատահաբար չգրանցեք ֆայլեր, որոնք իսկապես չեք ցանկանում ձեր Git պահոցում: Նախշերի կանոնները, որոնք կարող եք տեղադրել .gitignore ֆայլում, հետևյալն են.
1` # ֊ով սկսվող տողերը կամ դատարկ տողերը անտեսվում են
2` glob(! * [] ...և այլն) նիշերը կարող ենք կիրառել մեր ֆայլում
3` Գրացուցակ նշելու համար կարող եք նախշերը վերջացնել առաջ շեղով (/):
4` ! նշանով կարող ենք ժխտել միտքը

Glob-ի նախշերը նման են պարզեցված կանոնավոր արտահայտությունների: Աստղանիշը (*) համապատասխանում է զրո կամ ավելի նիշերի; [abc] համապատասխանում է փակագծերի ներսում գտնվող ցանկացած նիշի (այս դեպքում a, b կամ c); հարցական նշանը (?) համապատասխանում է մեկ նիշին; և փակագծերը, որոնք փակցնում են գծիկով առանձնացված նիշերը ([0-9]) համապատասխանում են նրանց միջև եղած ցանկացած նիշին (այս դեպքում 0-ից 9-ը): Դուք կարող եք նաև օգտագործել երկու աստղանիշ՝ ներդիր դիրեկտորիաներին համապատասխանեցնելու համար. a/**/z-ը կհամապատասխանի a/z, a/b/z, a/b/c/z և այլն

ևս մեկ .ignore ֊ի օրինակ 
# a  a կոմենտ է 
*.a       # անտեսել բոլոր .a ով վերջացող ֆայլերը տվյալ դիրեկտորիայում
!lib.a    # բացարությամբ lib.a ից (հաշվի արնելով վերևեվի տողը բոլոր .a ով վերջացողները հանում է բացարությամբ նշվածից)
/TODO     # only ignore the root TODO file, not subdir/TODO
build/    # անտեսել build/ ―ը ռեկուրսիվ եղանակով
doc/*.txt # անտեսել  doc/֊ում գտնվող բոլոր ֆայլերը որոնք վերջանում են .txt, բայց ոչ ռեկուրսիվ տարբերակով 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Viewing Your Staged and Unstaged Changes~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Եթե git status հրամանը չափազանց անորոշ է ձեզ համար, դուք ցանկանում եք իմանալ, թե կոնկրետ ինչ եք փոխել, ոչ թե միայն այն ֆայլերը, որոնք փոխվել են, կարող եք օգտագործել git diff հրամանը: Մենք ավելի մանրամասն կանդրադառնանք git diff-ին ավելի ուշ, բայց դուք, հավանաբար, ամենից հաճախ այն կօգտագործեք այս երկու հարցերին պատասխանելու համար. Ի՞նչ եք փոխել, բայց դեռ չեք բեմադրել: Իսկ ի՞նչ եք բեմադրել, որ պատրաստվում եք կատարել։ Չնայած git status պատասխանում է այդ հարցերին շատ ընդհանուր՝ թվարկելով ֆայլերի անունները, git diff-ը ձեզ ցույց է տալիս ավելացված և հեռացված ճշգրիտ տողերը:
Այդ հրամանը համեմատում է ձեր աշխատանքային գրացուցակում եղածը ձեր staged տարածքում եղածի հետ: Արդյունքը ցույց է տալիս ձեր կատարած փոփոխությունները, որոնք դեռ չեք բեմադրել (unstaged):
Եթե ցանկանում եք տեսնել, թե ինչ եք բեմադրել (staged), որը կանցնի ձեր հաջորդ commit-ին, կարող եք օգտագործել git diff --staged-ը:Այս հրամանը համեմատում է ձեր staged փոփոխությունները ձեր վերջին commit ֊ի հետ.
Կա մի շփոթեցնող հանգամանք, երբ իրականացնում ենք git diff նա համեմատում է staged ում գտնվող ֆայլի և վերջնական փոփոխված ֆայլի տարբերությունը։Սա կարող է շփոթեցնող լինել, քանի որ եթե դուք բեմադրել եք ձեր բոլոր փոփոխությունները, git diff-ը ձեզ արդյունք չի տա:
